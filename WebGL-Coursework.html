
<html lang="en-us">
<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { width: 100%; height: 100%; }
	</style>
</head>
<body>
<script src="three.js"></script>
<script src="OBJloader.js"></script>
<script src="scripts/controls.js"></script>
<script src="scripts/OrbitControls.js"></script>
<script type="module">
	"use strict"; // https://stackoverflow.com/q/1335851/72470
	import {MTLLoader} from 'http://localhost:8000/scripts/MTLLoader.js';
	import {FBXLoader} from "http://localhost:8000/scripts/FBXLoader.js";
	import {GLTFLoader} from "http://localhost:8000/scripts/GLTFLoader.js";
	import {TGALoader} from "http://localhost:8000/scripts/TGALoader.js";
	import Stats from 'http://localhost:8000/scripts/stats.module.js';
	import {GUI} from 'http://localhost:8000/scripts/dat.gui.module.js';

	// Global variables that are available in all functions.
	// Note: You can add your own here, e.g. to store the rendering mode.
	var camera, scene, renderer, mesh;
	// Bunny variables
	var geometry, bunnyObject, bunnyMesh = new THREE.Mesh(new THREE.Geometry(), null);
	// Ship Mesh
	var shipMesh, otherShipMesh, otherShipBound = 150, otherShipSpeed = 0.05;
	// Lighting
	var campFireLight;

	// GUI stats
	var stats = Stats();
	document.body.appendChild(stats.dom);

	// Initialise the scene, and draw it for the first time.
	init();
	animate();

	// Listen for keyboard events, to react to them.
	// Note: there are also other event listeners, e.g. for mouse events.
	document.addEventListener('keydown', handleKeyDown);
	//document.addEventListener("mousedown", mouseDownHandler);
	//document.addEventListener("mousemove", mouseMoveHandler);
	//document.addEventListener("mouseup", mouseUpHandler);


	// Scene initialisation. This function is only run once, at the very beginning.
	function init()
	{
		initCameraAndScene();



		loadBunny();

		// TO DO: Draw a cube (requirement 1).
		initCubeGeometry();
		renderCube();

		// TO DO: Visualise the axes of the global coordinate system (requirment 2).
		initXYZAxis();

		// Basic ambient lighting.
		scene.add(new THREE.AmbientLight(0xffffff, 0.5));

		// TO DO: add more complex lighting for 'face' rendering mode (requirement 4).
		campFireLight = new THREE.PointLight( 0xffff00, 2, 1000000000);
		campFireLight.castShadow = true;
		campFireLight.position.set( 9, 1, -18 );
		campFireLight.name = 'campFireLight';
		scene.add( campFireLight );

		renderGround();
		loadRequirement10(new THREE.Vector3(10, 0, -10));

		// Set up the Web GL renderer.
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		Controls.addMouseHandler(renderer.domElement, orbit, zoomIn, zoomOut);
		//controls = new THREE.OrbitControls( camera, renderer.domElement );

		initGUI();

		renderMovingShip();

		// Handle resizing of the browser window.
		window.addEventListener('resize', handleResize, false);
	}

	function drag( deltaY, deltaX) {

		deltaX = -deltaX;
		var centre = new THREE.Vector3();
		var radPerPixel = (Math.PI / 450),
				deltaPhi = radPerPixel * deltaX,
				deltaTheta = radPerPixel * deltaY,
				pos = camera.position.sub(centre),
				radius = pos.length(),
				theta = Math.acos(pos.z / radius),
				phi = Math.atan2(pos.y, pos.x);

		// Subtract deltaTheta and deltaPhi
		theta = Math.min(Math.max(theta - deltaTheta, 0), Math.PI);
		phi -= deltaPhi;

		// Turn back into Cartesian coordinates
		pos.x = (radius * Math.sin(theta) * Math.cos(phi));
		pos.y = (radius * Math.sin(theta) * Math.sin(phi));
		pos.z = (radius * Math.cos(theta));

		camera.position.add(centre);
		camera.lookAt(centre);
	}

	function initGUI()
	{
		const gui = new GUI({width: 500 });
		var campFireToggle = {toggle: function(){toggleCampFireLight()}};
		gui.add(campFireToggle, "toggle").name("Click to toggle campfire light!");
		var spawnDolphin = {spawn: function(){spawnRandomDolphin()}};
		gui.add(spawnDolphin, "spawn").name("Click to randomly spawn a dolphin!");

		const cubeFolder = gui.addFolder("Cube");
		var onlyFaces = {add: function(){renderCube()}};
		cubeFolder.add(onlyFaces, "add").name("Only Faces(Not affected by lighting)");
		onlyFaces = {add: function(){renderCubeLighting()}};
		cubeFolder.add(onlyFaces, "add").name("Only Faces(Affected by lighting)");
		var onlyVertices = {add: function(){renderCubeJustVertices();}};
		cubeFolder.add(onlyVertices, "add").name("Only Vertices");
		var onlyEdges = {add: function(){renderCubeJustEdges()}};
		cubeFolder.add(onlyEdges, "add").name("Only Edges");
		var addTextures = {add: function(){renderCubeTexturesNoLighting()}};
		cubeFolder.add(addTextures, "add").name("Textures On(Not affected by lighting)");
		addTextures = {add: function(){renderCubeTexturesLighting()}};
		cubeFolder.add(addTextures, "add").name("Textures On(Affected by lighting)");
		cubeFolder.open();

		const bunnyFolder = gui.addFolder("Bunny");
		onlyFaces = {add: function(){renderBunny()}};
		bunnyFolder.add(onlyFaces, "add").name("Only Faces");
		onlyVertices = {add: function(){renderBunnyJustVertices()}};
		bunnyFolder.add(onlyVertices, "add").name("Only Vertices");
		onlyEdges = {add: function(){renderBunnyJustEdges()}};
		bunnyFolder.add(onlyEdges, "add").name("Only Edges");
		var addTextures = {add: function(){renderBunnyLighting()}};
		bunnyFolder.add(addTextures, "add").name("Faces Affected by lighting");
		bunnyFolder.open();

		const cameraFolder = gui.addFolder("Camera");
		cameraFolder.add(camera.position, "x", -100, 100, 1);
		cameraFolder.add(camera.position, "y", -100, 100, 1);
		cameraFolder.add(camera.position, "z", -100, 100, 1);
		cameraFolder.open();

		const movingShipFolder = gui.addFolder("Moving Ship");
		var changeBoatSpeed = {toggle: function(){
			if(otherShipSpeed > 0.01) otherShipSpeed -= 0.01;
			else otherShipSpeed = 0.01;
		}};
		movingShipFolder.add(changeBoatSpeed, "toggle").name("Decrease Speed");
		changeBoatSpeed = {toggle: function(){
				if(otherShipSpeed < 1) otherShipSpeed += 0.01;
				else otherShipSpeed = 1;
			}};
		movingShipFolder.add(changeBoatSpeed, "toggle").name("Increase Speed");
		var changeBoatBound = {toggle: function(){
				if(otherShipBound > 5) otherShipBound -= 5;
				else otherShipBound = 5;
			}};
		movingShipFolder.add(changeBoatBound, "toggle").name("Decrease Max Bound");
		changeBoatBound = {toggle: function(){
				if(otherShipBound < 150) otherShipBound += 5;
				else otherShipBound = 150;
			}};
		movingShipFolder.add(changeBoatBound, "toggle").name("Increase Max Bound");

	}

	function zoomIn(scale)
	{
		console.log("told to zoom in");
		camera.translateZ(scale);
	}

	function zoomOut(scale)
	{
		console.log("told to zoom out");
		if(camera.position.z - scale > 0)
		{
			camera.translateZ(scale);
		}
	}

	function initCameraAndScene()
	{
		scene = new THREE.Scene();

		// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(3, 4, 5);
		camera.lookAt(new THREE.Vector3(0, 0, 0));

		// Draw a helper grid in the x-z plane (note: y is up).
		scene.add(new THREE.GridHelper(10, 20, 0xffffff));
	}

	function initCubeGeometry()
	{
		// Make a new geometry
		geometry = new THREE.Geometry();
		// Adding the corner vertices (8 vertices)
		geometry.vertices.push(
				new THREE.Vector3(-1, -1,  1),  // 0
				new THREE.Vector3( 1, -1,  1),  // 1
				new THREE.Vector3(-1,  1,  1),  // 2
				new THREE.Vector3( 1,  1,  1),  // 3
				new THREE.Vector3(-1, -1, -1),  // 4
				new THREE.Vector3( 1, -1, -1),  // 5
				new THREE.Vector3(-1,  1, -1),  // 6
				new THREE.Vector3( 1,  1, -1),  // 7
		);

		geometry.faces.push(
				// front
				new THREE.Face3(0, 3, 2),
				new THREE.Face3(0, 1, 3),
				// right
				new THREE.Face3(1, 7, 3),
				new THREE.Face3(1, 5, 7),
				// back
				new THREE.Face3(5, 6, 7),
				new THREE.Face3(5, 4, 6),
				// left
				new THREE.Face3(4, 2, 6),
				new THREE.Face3(4, 0, 2),
				// top
				new THREE.Face3(2, 7, 6),
				new THREE.Face3(2, 3, 7),
				// bottom
				new THREE.Face3(4, 1, 0),
				new THREE.Face3(4, 5, 1),
		);


	}

	function initXYZAxis()
	{
		var axisHelper = new THREE.AxesHelper(5);
		scene.add(axisHelper);
		/*
		// Alternative way to draw the xyz axis

		const range = 10;

		// X-Axis which is red
		const xAxisMaterial = new THREE.LineBasicMaterial({color: 0xFF0000});
		const xPoints = [];
		xPoints.push( new THREE.Vector3(0, 0, 0));
		xPoints.push( new THREE.Vector3(range, 0, 0));
		const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
		const xAxisLine = new THREE.Line(xAxisGeometry, xAxisMaterial);

		// Y-Axis which is green
		const yAxisMaterial = new THREE.LineBasicMaterial({color: 0x00FF00});
		const yPoints = [];
		yPoints.push( new THREE.Vector3(0, 0, 0));
		yPoints.push( new THREE.Vector3(0, range, 0));
		const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
		const yAxisLine = new THREE.Line(yAxisGeometry, yAxisMaterial);

		// Z-Axis which is blue
		const zAxisMaterial = new THREE.LineBasicMaterial({color: 0x0000FF});
		const zPoints = [];
		zPoints.push( new THREE.Vector3(0, 0, 0));
		zPoints.push( new THREE.Vector3(0, 0, range));
		const zAxisGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
		const zAxisLine = new THREE.Line(zAxisGeometry, zAxisMaterial);

		scene.add(xAxisLine);
		scene.add(yAxisLine);
		scene.add(zAxisLine);

		 */
	}


	// Handle resizing of the browser window.
	function handleResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function renderCube()
	{
		scene.remove(mesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshBasicMaterial({color: 0x0120FF});
		mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
	}

	function renderCubeLighting()
	{
		scene.remove(mesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
		mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
	}

	function renderBunny()
	{
		scene.remove(bunnyMesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshBasicMaterial({color: 0x0120FF});
		bunnyMesh = new THREE.Mesh(bunnyObject.children[0].geometry, material);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		scene.add(bunnyMesh);
	}

	function renderCubeJustVertices()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);

		// Adding a material to make the vertices visible
		// Points material only shows the points which in our case are 8 vertices
		const material = new THREE.PointsMaterial({color: 0x00ff00, size: 0.1});
		mesh = new THREE.Points(geometry, material);

		// Add the mesh back in the scene
		scene.add(mesh);
	}

	function renderBunnyJustVertices()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(bunnyMesh);

		// Adding a material to make the vertices visible
		// Points material only shows the points which in our case are 8 vertices
		const bunnyMaterial = new THREE.PointsMaterial({color: 0x0120FF, size: 0.01});
		bunnyMesh = new THREE.Points(bunnyObject.children[0].geometry, bunnyMaterial);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		// Add the mesh back in the scene
		scene.add(bunnyMesh);
	}

	function renderCubeJustEdges()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);

		// Adding a material to make the edges/wireframe visible
		// The material is told only to show the wireframe of the geometry
		const material = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true});
		mesh = new THREE.Mesh(geometry, material);

		// Add the mesh back in the scene
		scene.add(mesh);
	}

	function renderBunnyJustEdges()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(bunnyMesh);

		// Adding a material to make the edges/wireframe visible
		// The material is told only to show the wireframe of the geometry
		const material = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true});
		// Apply material to object
		bunnyMesh = new THREE.Mesh(bunnyObject.children[0].geometry, material);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		// Add the mesh back in the scene
		scene.add(bunnyMesh);
	}

	function loadBunny()
	{
		const loader = new THREE.OBJLoader();
		// load a resource
		loader.load(
				// resource URL
				'http://localhost:8000/bunny-5000.obj',
				// called when resource is loaded
				function ( object ) {
					bunnyObject = object;
					bunnyMesh = object;
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
		);
	}

	function renderCubeTexturesNoLighting()
	{
		scene.remove(mesh);

		const boxGeometry = new THREE.BoxBufferGeometry(2, 2, 2);
		const loader = new THREE.TextureLoader();
		const materials = [
			new THREE.MeshBasicMaterial({map: loader.load('https://res-3.cloudinary.com/crunchbase-production/image/upload/c_lpad,f_auto,q_auto:eco/taqpepcwzincpeytldot')}), //front right
			new THREE.MeshBasicMaterial({map: loader.load('https://static.wikia.nocookie.net/haikyuu/images/a/a1/Haikyuu_Poster.png/revision/latest/top-crop/width/220/height/220?cb=20140326213635')}), // back left
			new THREE.MeshBasicMaterial({map: loader.load('https://yt3.ggpht.com/ytc/AAUvwnifzf0a9h5PmkSSSEh_In8dRZasxvcdRpSQ2wM5SA=s900-c-k-c0x00ffffff-no-rj')}), // top
			new THREE.MeshBasicMaterial({map: loader.load('https://cdn.vox-cdn.com/thumbor/wQooBXM6ZRWVCkdI6W_KgDR1sjc=/0x0:1920x1200/1400x1400/filters:focal(1313x531:1619x837):format(jpeg)/cdn.vox-cdn.com/uploads/chorus_image/image/53947575/reinhammer.0.jpg')}), // bottom
			new THREE.MeshBasicMaterial({map: loader.load('https://i1.sndcdn.com/artworks-000118414405-0c9zmf-t500x500.jpg')}),// front left
			new THREE.MeshBasicMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')}), // back right
		];

		// If we want to apply a single texture change the second parameter to the material variable
		// Otherwise use materials variable
		mesh = new THREE.Mesh(boxGeometry, materials);

		scene.add(mesh);
	}

	function renderCubeTexturesLighting()
	{
		scene.remove(mesh);

		const boxGeometry = new THREE.BoxBufferGeometry(2, 2, 2);
		const loader = new THREE.TextureLoader();
		const materials = [
			new THREE.MeshPhongMaterial({map: loader.load('https://res-3.cloudinary.com/crunchbase-production/image/upload/c_lpad,f_auto,q_auto:eco/taqpepcwzincpeytldot')}), //front right
			new THREE.MeshPhongMaterial({map: loader.load('https://static.wikia.nocookie.net/haikyuu/images/a/a1/Haikyuu_Poster.png/revision/latest/top-crop/width/220/height/220?cb=20140326213635')}), // back left
			new THREE.MeshPhongMaterial({map: loader.load('https://yt3.ggpht.com/ytc/AAUvwnifzf0a9h5PmkSSSEh_In8dRZasxvcdRpSQ2wM5SA=s900-c-k-c0x00ffffff-no-rj')}), // top
			new THREE.MeshPhongMaterial({map: loader.load('https://cdn.vox-cdn.com/thumbor/wQooBXM6ZRWVCkdI6W_KgDR1sjc=/0x0:1920x1200/1400x1400/filters:focal(1313x531:1619x837):format(jpeg)/cdn.vox-cdn.com/uploads/chorus_image/image/53947575/reinhammer.0.jpg')}), // bottom
			new THREE.MeshPhongMaterial({map: loader.load('https://i1.sndcdn.com/artworks-000118414405-0c9zmf-t500x500.jpg')}),// front left
			new THREE.MeshPhongMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')}), // back right
		];

		// If we want to apply a single texture change the second parameter to the material variable
		// Otherwise use materials variable
		mesh = new THREE.Mesh(boxGeometry, materials);

		scene.add(mesh);
	}

	function renderBunnyLighting()
	{
		scene.remove(bunnyMesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshPhongMaterial({color: 0x0120FF});
		bunnyMesh = new THREE.Mesh(bunnyObject.children[0].geometry, material);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		scene.add(bunnyMesh);
	}

	function renderGround()
	{
		// Set up a plane and apply the water texture to make it look like an ocean
		let groundPlaneGeometry = new THREE.PlaneGeometry(300, 300 , 1, 1);

		var textureLoader = new THREE.TextureLoader();
		var map = textureLoader.load('http://localhost:8000/textures/water_texture.jpg');
		let material = new THREE.MeshStandardMaterial({map: map});

		let ground = new THREE.Mesh(groundPlaneGeometry, material);
		ground.castShadow = true;
		ground.receiveShadow = true;

		ground.rotateX(-Math.PI / 2);
		ground.position.y = -1;

		scene.add(ground);
	}

	function loadRequirement10(translationVector)
	{
		loadOBJModel('http://localhost:8000/models/buggy/Buggy.obj','http://localhost:8000/models/buggy/Buggy.jpg', new THREE.Vector3(0.05, 0.05, 0.05), (new THREE.Vector3(0,0,0)).addVectors(translationVector, new THREE.Vector3(5, 0.8, -7)), null);
		loadOBJModel('http://localhost:8000/models/camp/Camp.obj','http://localhost:8000/models/camp/camp.jpg', new THREE.Vector3(0.005, 0.005, 0.005),  (new THREE.Vector3(0,0,0)).addVectors(translationVector, new THREE.Vector3(5, 1, -2)), null);
		loadOBJModel('http://localhost:8000/models/dolphin/dolphin_jumping.obj', 'http://localhost:8000/models/dolphin/dolphin-tex.png',  new THREE.Vector3(2, 2, 2), new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(-10, -7, -10)), null);
		loadOBJMTLModel('http://localhost:8000/models/zoro/','zoro.obj', 'zoro.mtl',  new THREE.Vector3(0.035, 0.035, 0.035),  new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(7, -0.2, -1)), new THREE.Vector3(-90*Math.PI/180, 0*Math.PI/180, 230*Math.PI/180));
		// Load the ship that can be moved
		loadShip('http://localhost:8000/models/ship/', 'ship.obj', 'ship.mtl',  new THREE.Vector3(1, 1, 1),  new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(10, -1, 6)));
		// Load tower hut to add to the buildings
		loadOBJMTLModel('http://localhost:8000/models/tower_hut/','tower.obj', 'tower.mtl',  new THREE.Vector3(1.5, 1.5, 1.5),  new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(-5, -1, -20)), null);
		// Load Luffy on deck
		loadOBJMTLModel('http://localhost:8000/models/luffy/','luffy.obj', 'luffy.mtl',  new THREE.Vector3(0.02, 0.02, 0.02),  new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(-5, 0.5, -16)), new THREE.Vector3(0*Math.PI/180, 45*Math.PI/180, 0*Math.PI/180));
		// Load Chopper under the tent
		loadOBJMTLModel('http://localhost:8000/models/chopper/','chopper.obj', 'chopper.mtl',  new THREE.Vector3(0.02, 0.02, 0.02),  new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(6, 0.8, -10)), new THREE.Vector3(0*Math.PI/180, 5*Math.PI/180, 0*Math.PI/180));
		// Load Nami on top of tower
		loadGLTFModel('http://localhost:8000/models/nami/scene.gltf', new THREE.Vector3(7, 7, 7), new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(-3, 8, -17)), new THREE.Vector3(0*Math.PI/180, 45*Math.PI/180, 0*Math.PI/180));
		// Load Usopp on top of the barrel
		loadGLTFModel('http://localhost:8000/models/usopp/scene.gltf' , new THREE.Vector3(1.25, 1.25, 1.25) , (new THREE.Vector3(0,0,0)).addVectors(translationVector, new THREE.Vector3(3.5, 3.9, -14.5)), null);
		// Load Sanji on top of the tower
		loadGLTFModel('http://localhost:8000/models/sanji/scene.gltf' , new THREE.Vector3(0.015, 0.015, 0.015) , new THREE.Vector3().addVectors(translationVector, new THREE.Vector3(0, 8, -19)), new THREE.Vector3(0*Math.PI/180, -45*Math.PI/180, 0*Math.PI/180));
	}

	function loadOBJModel(url, textureUrl, scaleVector, translateVector, rotateVector)
	{
		var material;

		// load a resource
		const loader = new THREE.OBJLoader();
		loader.load(
				// resource URL
				url,
				// called when resource is loaded
				function ( object )
				{
					let objectMesh = object;
					if(textureUrl != null)
					{
						var textureLoader = new THREE.TextureLoader();
						var map = textureLoader.load(textureUrl);
						material = new THREE.MeshPhongMaterial({map: map});
						objectMesh = new THREE.Mesh(object.children[0].geometry, material);
					}

					if(scaleVector!=null) objectMesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
					if(translateVector!=null) {
						objectMesh.translateX(translateVector.x);
						objectMesh.translateY(translateVector.y);
						objectMesh.translateZ(translateVector.z);
					}
					if(rotateVector!=null)
					{
						objectMesh.rotateX(rotateVector.x);
						objectMesh.rotateY(rotateVector.y);
						objectMesh.rotateZ(rotateVector.z);
					}
					scene.add(objectMesh);
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
		);
	}

	function loadFBXModel(fbxUrl, scaleVector, translateVector, rotateVector)
	{
		const manager = new THREE.LoadingManager();
		manager.addHandler( /\.tga$/i, new TGALoader() );
		// load a resource
		const loader = new FBXLoader(manager);
		loader.load(
				// resource URL
				fbxUrl,
				// called when resource is loaded
				function ( object )
				{
					let objectMesh = object;

					if(scaleVector!=null) objectMesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
					if(translateVector!=null) {
						objectMesh.translateX(translateVector.x);
						objectMesh.translateY(translateVector.y);
						objectMesh.translateZ(translateVector.z);
					}
					if(rotateVector!=null)
					{
						objectMesh.rotateX(rotateVector.x);
						objectMesh.rotateY(rotateVector.y);
						objectMesh.rotateZ(rotateVector.z);
					}
					scene.add(objectMesh);
				}
		);
	}

	function loadGLTFModel(gltfUrl, scaleVector, translateVector, rotateVector)
	{
		// load a resource
		const loader = new GLTFLoader();
		loader.load(
				// resource URL
				gltfUrl,
				// called when resource is loaded
				function ( object )
				{
					let objectMesh = object.scene;

					if(scaleVector!=null) objectMesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
					if(translateVector!=null) {
						objectMesh.translateX(translateVector.x);
						objectMesh.translateY(translateVector.y);
						objectMesh.translateZ(translateVector.z);
					}
					if(rotateVector!=null)
					{
						objectMesh.rotateX(rotateVector.x);
						objectMesh.rotateY(rotateVector.y);
						objectMesh.rotateZ(rotateVector.z);
					}
					scene.add(objectMesh);
				}
		);
	}

	function loadOtherShip(fbxUrl, scaleVector, translateVector, rotateVector)
	{
		// load a resource
		const loader = new FBXLoader();
		loader.load(
				// resource URL
				fbxUrl,
				// called when resource is loaded
				function ( object )
				{
					otherShipMesh = object;

					if(scaleVector!=null) otherShipMesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
					if(translateVector!=null) {
						otherShipMesh.translateX(translateVector.x);
						otherShipMesh.translateY(translateVector.y);
						otherShipMesh.translateZ(translateVector.z);
					}
					if(rotateVector!=null)
					{
						otherShipMesh.rotateX(rotateVector.x);
						otherShipMesh.rotateY(rotateVector.y);
						otherShipMesh.rotateZ(rotateVector.z);
					}
					scene.add(otherShipMesh);
				}
		);
	}

	function loadOBJMTLModel(path, objURL, mtlURL,scaleVector, translateVector, rotateVector)
	{
		// initialise the loaders
		var mtlLoader = new MTLLoader();
		var objLoader = new THREE.OBJLoader();
		mtlLoader.setPath(path);
		objLoader.setPath(path);

		mtlLoader.load(
				// resource URL
				mtlURL,
				// called when resource is loaded
				function ( materials )
				{
					materials.preload();

					objLoader.setMaterials(materials);
					objLoader.load(objURL, function (object) {
						if(scaleVector!=null) object.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
						if(translateVector!=null) {
							object.translateX(translateVector.x);
							object.translateY(translateVector.y);
							object.translateZ(translateVector.z);
						}
						if(rotateVector!=null)
						{
							object.rotateX(rotateVector.x);
							object.rotateY(rotateVector.y);
							object.rotateZ(rotateVector.z);
						}

						scene.add(object);
						return object;
					})
				});
	}

	function loadShip(path, objURL, mtlURL,scaleVector, translateVector)
	{
		// initialise the loaders
		var mtlLoader = new MTLLoader();
		var objLoader = new THREE.OBJLoader();
		mtlLoader.setPath(path);
		objLoader.setPath(path);

		mtlLoader.load(
				// resource URL
				mtlURL,
				// called when resource is loaded
				function ( materials )
				{
					materials.preload();

					objLoader.setMaterials(materials);
					objLoader.load(objURL, function (object) {
						if(scaleVector!=null) object.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
						if(translateVector!=null) {
							object.translateX(translateVector.x);
							object.translateY(translateVector.y);
							object.translateZ(translateVector.z);
						}

						shipMesh = object;
						scene.add(shipMesh);
					})
				});
	}

	function renderMovingShip()
	{
		loadOtherShip('http://localhost:8000/models/endurance_ship/source/Endurance_LowPoly.fbx', new THREE.Vector3(0.05, 0.05, 0.05), new THREE.Vector3(50, -1, -30), null);
	}

	function spawnRandomDolphin()
	{
		let randomYAngle = Math.random() * (2 * Math.PI);

		let randomXPosition = getRandomInteger(-140, 140);
		while(randomXPosition < 20 && randomXPosition > -20){
			randomXPosition = getRandomInteger(-140, 140);
		}
		let randomZPosition = getRandomInteger(-140, 140);
		while(randomZPosition < 20 && randomZPosition > -20){
			randomZPosition = getRandomInteger(-140, 140);
		}
		loadOBJModel('http://localhost:8000/models/dolphin/dolphin_jumping.obj', 'http://localhost:8000/models/dolphin/dolphin-tex.png',  new THREE.Vector3(2, 2, 2), new THREE.Vector3(randomXPosition, -6, randomZPosition), new THREE.Vector3(0, randomYAngle, 0));

	}

	function getRandomInteger(min, max)
	{
		return Math.floor(Math.random() * (max-min)) + min;
	}

	// Animation loop function. This function is called whenever an update is required.
	function animate()
	{
		requestAnimationFrame(animate);

		if(otherShipMesh!=null)
		{
			moveOtherShip(otherShipSpeed, otherShipBound);
		}

		//controls.update();
		stats.update();

		// Render the current scene to the screen.
		renderer.render(scene, camera);

		// TO DO: This is a good place for code that rotates your cube (requirement 3).
		/*
		mesh.rotation.x += 0.001;
		mesh.rotation.y += 0.001;
		mesh.rotation.z += 0.001;
		orbit(0.0005, 0);

		 */

	}

	function moveShip(x, yAngle)
	{
		if(x!=null)
		{
			shipMesh.translateX(x);
		}
		if(yAngle!=null)
		{
			shipMesh.rotateY(yAngle);
		}
	}

	function moveOtherShip(z, bound)
	{
		// If out of bounds then rotate
		if( otherShipMesh.position.z > bound || otherShipMesh.position.z < -bound )
		{
			otherShipMesh.rotateY(Math.PI);
			otherShipMesh.translateZ(-30);
		}
		else
		{
			otherShipMesh.translateZ(-z);
		}
	}

	// Handle keyboard presses.
	function handleKeyDown(event)
	{
		switch (event.keyCode)
		{
				// Render modes.
			case 70: // f = face
				renderCube();
				//for(mesh.)
				break;

			case 69: // e = edge
				renderCubeJustEdges();
				break;

			case 86: // v = vertex
				renderCubeJustVertices();
				break;

				// TO DO: add code for starting/stopping rotations (requirement 3).
			case 88: // x = trigger rotating cube about x axis
				mesh.rotation.x += 0.01;
				bunnyMesh.rotation.x += 0.01;
				break;

			case 89: // y = trigger rotating cube about y axis
				mesh.rotation.y += 0.01;
				bunnyMesh.rotation.y += 0.01;

				break;
			case 90: // z = trigger rotating cube about z axis
				mesh.rotation.z += 0.01;
				bunnyMesh.rotation.z += 0.01;
				break;

			case 82: // r = reset rotation
				mesh.rotation.x = 0;
				mesh.rotation.y = 0;
				mesh.rotation.z = 0;

				bunnyMesh.rotation.x = 0;
				bunnyMesh.rotation.y = 0;
				bunnyMesh.rotation.z = 0;

				break;

			case 38: // arrow up
				camera.translateY(1);
				break;

			case 40: // arrow down
				camera.translateY(-1);
				break;

			case 37: // arrow left
				camera.translateX(-1);
				break;

			case 39: // arrow right
				camera.translateX(1);
				break;

			case 87: // w = camera forward
				zoomIn(1);
				break;

			case 83: // s = camera backwards
				zoomOut(1);
				break;

			case 104: // 8 = orbit in the upwards direction
				orbit(0, 0.01);
				break;

			case 100: // 4 = orbit in the left direction
				orbit(-0.01, 0);
				break;

			case 102: // 6 = orbit in the right direction
				orbit(0.01, 0.);
				break;

			case 98: // 2 = orbit in the upwards direction
				orbit(0, -0.01);
				break

			case 73: //i = move ship forward
				moveShip(-1, null);
				break;

			case 74: //j = rotate ship left
				moveShip(null, 15*Math.PI/180);
				break;

			case 75: //k = move ship backward
				moveShip(1, null);
				break;

			case 76: //l = move ship right
				moveShip(null, -15*Math.PI/180);
				break;
		}
	}

	function toggleCampFireLight()
	{
		// If already in scene then remove
		if(scene.getObjectByName('campFireLight'))
		{
			scene.remove(campFireLight);
		}
		// If not in scene then add it
		else
		{
			campFireLight.name = 'campFireLight';
			scene.add(campFireLight);
		}
	}

	function orbit(deltaX, deltaY)
	{
		deltaX *= 0.01;
		deltaY *= 0.01;

		var center = new THREE.Vector3();
		var radius, phi, theta;
		var pos = camera.position;
		// Convert current camera position to spherical coordinates
		radius = pos.length();
		phi = Math.atan(pos.x / pos.z);
		theta = Math.acos(pos.y / radius);

		// Subtract angles to mimic translation in an orbit manner
		phi -= deltaX;
		theta -= deltaY;

		// Need to check the sign of the z coordinate to invert the positions accordingly
		if(pos.z < 0)
		{
			// Convert the spherical to cartesian coordinates
			camera.position.x = -radius * Math.sin(theta) * Math.sin(phi);
			camera.position.y = radius * Math.cos(theta);
			camera.position.z = -radius * Math.sin(theta) * Math.cos(phi);
		}
		else
		{
			// Convert the spherical to cartesian coordinates
			camera.position.x = radius * Math.sin(theta) * Math.sin(phi);
			camera.position.y = radius * Math.cos(theta);
			camera.position.z = radius * Math.sin(theta) * Math.cos(phi);
		}

		camera.lookAt(center);
	}
/*
	function mouseDownHandler(event)
	{
		// Get x and y position when mouse is pressed down
		startXPosition = event.offsetX;
		startXPosition = event.offsetX;
		mouseDown = true;
		console.log("Mouse Down");

	}

	function mouseUpHandler()
	{
		mouseDown = false;
		console.log("Mouse Up");
	}

	// Every move updates the orbit
	function mouseMoveHandler(event)
	{
		console.log("Mouse Moving");

		// If the event does not get explicitly handles, default action should not be taken
		event.preventDefault();
		// If mouse is not down don't need to worry about the movement
		if(!mouseDown) return;
		console.log("start position is not null")
		// Choice for orbiting camera scalar
		const scalar = 0.001;
		// Get how much the mouse has moved in the x and y axis
		var deltaX, deltaY;
		deltaX = (startXPosition - event.offsetX) * scalar;
		deltaY = (startYPosition - event.offsetY) * scalar;

		// Trigger orbit
		orbit(deltaX, deltaY);

		// Update the x and y coordinate
		startXPosition = event.offsetX;
		startXPosition = event.offsetX;
	}

 */

</script>
</body>
</html>