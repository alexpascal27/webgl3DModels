
<html lang="en-us">
<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { width: 100%; height: 100%; }
	</style>
</head>
<body>
<script src="three.js"></script>
<script src="OBJloader.js"></script>
<script src="scripts/controls.js"></script>
<script src="scripts/OrbitControls.js"></script>
<script type="module" src="http://localhost:8000/scripts/MTLLoader.js"></script>
<script type="module">
	"use strict"; // https://stackoverflow.com/q/1335851/72470

	// Global variables that are available in all functions.
	// Note: You can add your own here, e.g. to store the rendering mode.
	import {MTLLoader} from 'http://localhost:8000/scripts/MTLLoader.js';

	var camera, scene, renderer, mesh;
	var geometry, bunnyObject, bunnyMesh;
	var controls;

	// Initialise the scene, and draw it for the first time.
	init();
	animate();

	// Listen for keyboard events, to react to them.
	// Note: there are also other event listeners, e.g. for mouse events.
	document.addEventListener('keydown', handleKeyDown);
	document.addEventListener('mousewheel', handleMouseWheel);
	document.addEventListener('mousemove', handleMouseMovement);

	// Scene initialisation. This function is only run once, at the very beginning.
	function init()
	{
		initCameraAndScene();

		loadObject();

		// TO DO: Draw a cube (requirement 1).
		initCubeGeometry();
		loadCube();

		// TO DO: Visualise the axes of the global coordinate system (requirment 2).
		initXYZAxis();

		// Basic ambient lighting.
		scene.add(new THREE.AmbientLight(0xffffff, 0.5));


		// TO DO: add more complex lighting for 'face' rendering mode (requirement 4).
		const light = new THREE.PointLight( 0xffff00, 2, 1000000000);
		light.castShadow = true;
		light.position.set( -1, 1, -10 );
		scene.add( light );

		loadOBJModel('http://localhost:8000/models/buggy/Buggy.obj','http://localhost:8000/models/buggy/Buggy.jpg', new THREE.Vector3(0.05, 0.05, 0.05), new THREE.Vector3(5, 0.8, -5));
		loadOBJModel('http://localhost:8000/models/camp/Camp.obj','http://localhost:8000/models/camp/camp.jpg', new THREE.Vector3(0.005, 0.005, 0.005), new THREE.Vector3(5, 1, -2));
		loadOBJModel('http://localhost:8000/bunny-5000.obj','http://localhost:8000/bunny-atlas.jpg', new THREE.Vector3(1, 1, 1), new THREE.Vector3(-5, 1, -2));
		loadOBJMTLModel('http://localhost:8000/models/naruto/','Naruto.obj', 'Naruto.mtl',  new THREE.Vector3(0.5, 0.5, 0.5),  new THREE.Vector3(5, 0.8, -3));
		loadOBJMTLModel('http://localhost:8000/models/ship/','ship.obj', 'ship.mtl',  new THREE.Vector3(1, 1, 1),  new THREE.Vector3(10, -1, 10));

		loadGround();

		// Set up the Web GL renderer.
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		//Controls.addMouseHandler(renderer.domElement, orbit, zoomIn, zoomOut);
		controls = new THREE.OrbitControls( camera, renderer.domElement );


		// Handle resizing of the browser window.
		window.addEventListener('resize', handleResize, false);
	}

	function zoomIn()
	{
		camera.translateZ(-0.1);
	}

	function zoomOut()
	{
		camera.translateZ(0.1);
	}

	function initCameraAndScene()
	{
		scene = new THREE.Scene();

		// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(3, 4, 5);
		camera.lookAt(new THREE.Vector3(0, 0, 0));

		// Draw a helper grid in the x-z plane (note: y is up).
		scene.add(new THREE.GridHelper(10, 20, 0xffffff));
	}

	function initCubeGeometry()
	{
		// Make a new geometry
		geometry = new THREE.Geometry();
		// Adding the corner vertices (8 vertices)
		geometry.vertices.push(
				new THREE.Vector3(-1, -1,  1),  // 0
				new THREE.Vector3( 1, -1,  1),  // 1
				new THREE.Vector3(-1,  1,  1),  // 2
				new THREE.Vector3( 1,  1,  1),  // 3
				new THREE.Vector3(-1, -1, -1),  // 4
				new THREE.Vector3( 1, -1, -1),  // 5
				new THREE.Vector3(-1,  1, -1),  // 6
				new THREE.Vector3( 1,  1, -1),  // 7
		);

		geometry.faces.push(
				// front
				new THREE.Face3(0, 3, 2),
				new THREE.Face3(0, 1, 3),
				// right
				new THREE.Face3(1, 7, 3),
				new THREE.Face3(1, 5, 7),
				// back
				new THREE.Face3(5, 6, 7),
				new THREE.Face3(5, 4, 6),
				// left
				new THREE.Face3(4, 2, 6),
				new THREE.Face3(4, 0, 2),
				// top
				new THREE.Face3(2, 7, 6),
				new THREE.Face3(2, 3, 7),
				// bottom
				new THREE.Face3(4, 1, 0),
				new THREE.Face3(4, 5, 1),
		);


	}

	function initXYZAxis()
	{
		var axisHelper = new THREE.AxesHelper(5);
		scene.add(axisHelper);
		/*
		// Alternative way to draw the xyz axis

		const range = 10;

		// X-Axis which is red
		const xAxisMaterial = new THREE.LineBasicMaterial({color: 0xFF0000});
		const xPoints = [];
		xPoints.push( new THREE.Vector3(0, 0, 0));
		xPoints.push( new THREE.Vector3(range, 0, 0));
		const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
		const xAxisLine = new THREE.Line(xAxisGeometry, xAxisMaterial);

		// Y-Axis which is green
		const yAxisMaterial = new THREE.LineBasicMaterial({color: 0x00FF00});
		const yPoints = [];
		yPoints.push( new THREE.Vector3(0, 0, 0));
		yPoints.push( new THREE.Vector3(0, range, 0));
		const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
		const yAxisLine = new THREE.Line(yAxisGeometry, yAxisMaterial);

		// Z-Axis which is blue
		const zAxisMaterial = new THREE.LineBasicMaterial({color: 0x0000FF});
		const zPoints = [];
		zPoints.push( new THREE.Vector3(0, 0, 0));
		zPoints.push( new THREE.Vector3(0, 0, range));
		const zAxisGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
		const zAxisLine = new THREE.Line(zAxisGeometry, zAxisMaterial);

		scene.add(xAxisLine);
		scene.add(yAxisLine);
		scene.add(zAxisLine);

		 */
	}

	function renderTextures()
	{
		scene.remove(mesh);

		const boxGeometry = new THREE.BoxBufferGeometry(2, 2, 2);
		const loader = new THREE.TextureLoader();
		const material = new THREE.MeshPhongMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')});

		const materials = [
			new THREE.MeshPhongMaterial({map: loader.load('https://res-3.cloudinary.com/crunchbase-production/image/upload/c_lpad,f_auto,q_auto:eco/taqpepcwzincpeytldot')}), //front right
			new THREE.MeshPhongMaterial({map: loader.load('https://static.wikia.nocookie.net/haikyuu/images/a/a1/Haikyuu_Poster.png/revision/latest/top-crop/width/220/height/220?cb=20140326213635')}), // back left
			new THREE.MeshPhongMaterial({map: loader.load('https://yt3.ggpht.com/ytc/AAUvwnifzf0a9h5PmkSSSEh_In8dRZasxvcdRpSQ2wM5SA=s900-c-k-c0x00ffffff-no-rj')}), // top
			new THREE.MeshPhongMaterial({map: loader.load('https://cdn.vox-cdn.com/thumbor/wQooBXM6ZRWVCkdI6W_KgDR1sjc=/0x0:1920x1200/1400x1400/filters:focal(1313x531:1619x837):format(jpeg)/cdn.vox-cdn.com/uploads/chorus_image/image/53947575/reinhammer.0.jpg')}), // bottom
			new THREE.MeshPhongMaterial({map: loader.load('https://i1.sndcdn.com/artworks-000118414405-0c9zmf-t500x500.jpg')}),// front left
			new THREE.MeshPhongMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')}), // back right
		];

		// If we want to apply a single texture change the second parameter to the material variable
		// Otherwise use materials variable
		mesh = new THREE.Mesh(boxGeometry, materials);

		scene.add(mesh);
	}

	// Handle resizing of the browser window.
	function handleResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function loadCubeJustVertices()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);
		scene.remove(bunnyMesh);

		// Adding a material to make the vertices visible
		// Points material only shows the points which in our case are 8 vertices
		const material = new THREE.PointsMaterial({color: 0x00ff00, size: 0.1});
		mesh = new THREE.Points(geometry, material);

		const bunnyMaterial = new THREE.PointsMaterial({color: 0x00ff00, size: 0.01});
		bunnyMesh = new THREE.Points(bunnyObject.children[0].geometry, bunnyMaterial);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		// Add the mesh back in the scene
		scene.add(mesh);
		scene.add(bunnyMesh);
	}

	function loadCubeJustEdges()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);
		scene.remove(bunnyMesh);

		// Adding a material to make the edges/wireframe visible
		// The material is told only to show the wireframe of the geometry
		const material = new THREE.MeshP
		Material({color: 0x00ff00, wireframe: true});
		mesh = new THREE.Mesh(geometry, material);

		// Apply material to object
		bunnyMesh = new THREE.Mesh(bunnyObject.children[0].geometry, material);
		// Adjust scale
		bunnyMesh.scale.set(0.4, 0.4, 0.4);
		bunnyMesh.translateX(-0.4);

		// Add the mesh back in the scene
		scene.add(mesh);
		scene.add(bunnyMesh);
	}

	function loadCube()
	{
		scene.remove(mesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshPhongMaterial({color: 0x0120FF});
		mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
	}

	function loadObject()
	{
		const loader = new THREE.OBJLoader();
		// load a resource
		loader.load(
				// resource URL
				'http://localhost:8000/bunny-5000.obj',
				// called when resource is loaded
				function ( object ) {
					bunnyObject = object;
					bunnyMesh = object;
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
		);
	}

	function loadGround()
	{
		// Set up a plane and apply the water texture to make it look like an ocean
		let groundPlaneGeometry = new THREE.PlaneGeometry(100, 100 , 100, 100);

		var textureLoader = new THREE.TextureLoader();
		var map = textureLoader.load('http://localhost:8000/textures/water_texture.jpg');
		let material = new THREE.MeshStandardMaterial({map: map});

		let ground = new THREE.Mesh(groundPlaneGeometry, material);
		ground.castShadow = true;
		ground.receiveShadow = true;

		ground.rotateX(-Math.PI / 2);
		ground.position.y = -1;

		scene.add(ground);
	}

	function loadOBJModel(url, textureUrl, scaleVector, translateVector)
	{
		var material;

		// load a resource
		const loader = new THREE.OBJLoader();
		loader.load(
				// resource URL
				url,
				// called when resource is loaded
				function ( object )
				{
					let objectMesh = object;
					if(textureUrl != null)
					{
						var textureLoader = new THREE.TextureLoader();
						var map = textureLoader.load(textureUrl);
						material = new THREE.MeshPhongMaterial({map: map});
						objectMesh = new THREE.Mesh(object.children[0].geometry, material);
					}

					if(scaleVector!=null) objectMesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
					if(translateVector!=null) {
						objectMesh.translateX(translateVector.x);
						objectMesh.translateY(translateVector.y);
						objectMesh.translateZ(translateVector.z);
					}
					scene.add(objectMesh);
				},
				// called when loading is in progresses
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// called when loading has errors
				function ( error ) {
					console.log( 'An error happened' );
				}
		);
	}

	function loadOBJMTLModel(path, objURL, mtlURL,scaleVector, translateVector)
	{

		// initialise the loaders
		var mtlLoader = new MTLLoader();
		var objLoader = new THREE.OBJLoader();
		mtlLoader.setPath(path);
		objLoader.setPath(path);


		mtlLoader.load(
				// resource URL
				mtlURL,
				// called when resource is loaded
				function ( materials )
				{
					materials.preload();

					objLoader.setMaterials(materials);
					objLoader.load(objURL, function (object) {
						if(scaleVector!=null) object.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
						if(translateVector!=null) {
							object.translateX(translateVector.x);
							object.translateY(translateVector.y);
							object.translateZ(translateVector.z);
						}

						scene.add(object);
					})
				});
	}

	// Animation loop function. This function is called whenever an update is required.
	function animate()
	{
		requestAnimationFrame(animate);

		// TO DO: This is a good place for code that rotates your cube (requirement 3).
		/*
		mesh.rotation.x += 0.001;
		mesh.rotation.y += 0.001;
		mesh.rotation.z += 0.001;
		orbit(0.0005, 0);

		 */

		controls.update();

		// Render the current scene to the screen.
		renderer.render(scene, camera);
	}

	// Handle keyboard presses.
	function handleKeyDown(event)
	{
		switch (event.keyCode)
		{
				// Render modes.
			case 70: // f = face
				loadCube();
				//for(mesh.)
				break;

			case 69: // e = edge
				loadCubeJustEdges();
				break;

			case 86: // v = vertex
				loadCubeJustVertices();
				break;

				// TO DO: add code for starting/stopping rotations (requirement 3).
			case 88: // x = trigger rotating cube about x axis
				mesh.rotation.x += 0.01;
				bunnyMesh.rotation.x += 0.01;

				break;

			case 89: // y = trigger rotating cube about y axis
				mesh.rotation.y += 0.01;
				bunnyMesh.rotation.y += 0.01;

				break;
			case 90: // z = trigger rotating cube about z axis
				mesh.rotation.z += 0.01;
				bunnyMesh.rotation.z += 0.01;
				break;

			case 82: // r = reset rotation
				mesh.rotation.x = 0;
				mesh.rotation.y = 0;
				mesh.rotation.z = 0;

				bunnyMesh.rotation.x = 0;
				bunnyMesh.rotation.y = 0;
				bunnyMesh.rotation.z = 0;

				break;

			case 38: // arrow up
				camera.translateY(0.05);
				break;

			case 40: // arrow down
				camera.translateY(-0.05);
				break;

			case 37: // arrow left
				camera.translateX(-0.05);
				break;

			case 39: // arrow right
				camera.translateX(0.05);
				break;

			case 87: // w = camera forward
				camera.translateZ(-0.1);
				break;

			case 83: // s = camera backwards
				camera.translateZ(0.1);
				break;

			case 84: // t = render textures
				renderTextures();
				break;

			case 104: // 8 = orbit in the upwards direction
				orbit(0, 0.01);
				break;

			case 100: // 4 = orbit in the left direction
				orbit(-0.01, 0);
				break;

			case 102: // 6 = orbit in the right direction
				orbit(0.01, 0.);
				break;

			case 98: // 2 = orbit in the upwards direction
				orbit(0, -0.01);
		}
	}

	// Handle mouse movement
	function handleMouseEvent(event)
	{

	}

	// Handle mouse wheel movement
	function handleMouseWheel(event)
	{

	}

	function orbit(angleY, angleX)
	{
		angleX = -angleX;

		angleX *= Math.PI/450;
		angleY *= Math.PI/450;

		var center = new THREE.Vector3();
		var radius, phi, theta;
		var pos = camera.position;
		// Convert current camera position to spherical coordinates
		radius = pos.length();
		phi = Math.atan2(pos.y, pos.x); // corresponds to the angle between x axis and radius line
		theta = Math.acos(pos.z / radius); // corresponds to the angle between y axis and radius line

		// Subtract angles to mimic translation in an orbit manner
		phi -= angleX;
		theta = Math.min(Math.max(theta - angleY, 0), Math.PI);

		// Convert the spherical to cartesian coordinates
		pos.x = radius * Math.sin(theta) * Math.cos(phi);
		pos.y = radius * Math.sin(theta) * Math.sin(phi);
		pos.z = radius * Math.cos(theta);

		camera.position.add(center);
		camera.lookAt(center);
	}


</script>
</body>
</html>