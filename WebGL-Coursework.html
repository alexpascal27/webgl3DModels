
<html lang="en-us">
<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { width: 100%; height: 100%; }
	</style>
</head>
<body>
<script src="three.js"></script>
<script src="OBJloader.js"></script>
<script>

	"use strict"; // https://stackoverflow.com/q/1335851/72470

	// Global variables that are available in all functions.
	// Note: You can add your own here, e.g. to store the rendering mode.
	var camera, scene, renderer, mesh;
	var geometry, bunnyObject, bunnyMesh;

	// Initialise the scene, and draw it for the first time.
	init();
	animate();

	// Listen for keyboard events, to react to them.
	// Note: there are also other event listeners, e.g. for mouse events.
	document.addEventListener('keydown', handleKeyDown);

	// Scene initialisation. This function is only run once, at the very beginning.
	function init()
	{
		initCameraAndScene();

		loadObject();

		// TO DO: Draw a cube (requirement 1).
		initCubeGeometry();
		loadCube();

		// TO DO: Visualise the axes of the global coordinate system (requirment 2).
		initXYZAxis();

		// Basic ambient lighting.
		scene.add(new THREE.AmbientLight(0xffffff));
		// TO DO: add more complex lighting for 'face' rendering mode (requirement 4).


		// Set up the Web GL renderer.
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		// Handle resizing of the browser window.
		window.addEventListener('resize', handleResize, false);
	}

	function initCameraAndScene()
	{
		scene = new THREE.Scene();

		// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(3, 4, 5);
		camera.lookAt(new THREE.Vector3(0, 0, 0));

		// Draw a helper grid in the x-z plane (note: y is up).
		scene.add(new THREE.GridHelper(10, 20, 0xffffff));
	}

	function initCubeGeometry()
	{
		// Make a new geometry
		geometry = new THREE.Geometry();
		// Adding the corner vertices (8 vertices)
		geometry.vertices.push(
				new THREE.Vector3(-1, -1,  1),  // 0
				new THREE.Vector3( 1, -1,  1),  // 1
				new THREE.Vector3(-1,  1,  1),  // 2
				new THREE.Vector3( 1,  1,  1),  // 3
				new THREE.Vector3(-1, -1, -1),  // 4
				new THREE.Vector3( 1, -1, -1),  // 5
				new THREE.Vector3(-1,  1, -1),  // 6
				new THREE.Vector3( 1,  1, -1),  // 7
		);

		geometry.faces.push(
				// front
				new THREE.Face3(0, 3, 2),
				new THREE.Face3(0, 1, 3),
				// right
				new THREE.Face3(1, 7, 3),
				new THREE.Face3(1, 5, 7),
				// back
				new THREE.Face3(5, 6, 7),
				new THREE.Face3(5, 4, 6),
				// left
				new THREE.Face3(4, 2, 6),
				new THREE.Face3(4, 0, 2),
				// top
				new THREE.Face3(2, 7, 6),
				new THREE.Face3(2, 3, 7),
				// bottom
				new THREE.Face3(4, 1, 0),
				new THREE.Face3(4, 5, 1),
		);


	}

	function initXYZAxis()
	{
		var axisHelper = new THREE.AxesHelper(5);
		scene.add(axisHelper);
		/*
		// Alternative way to draw the xyz axis

		const range = 10;

		// X-Axis which is red
		const xAxisMaterial = new THREE.LineBasicMaterial({color: 0xFF0000});
		const xPoints = [];
		xPoints.push( new THREE.Vector3(0, 0, 0));
		xPoints.push( new THREE.Vector3(range, 0, 0));
		const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
		const xAxisLine = new THREE.Line(xAxisGeometry, xAxisMaterial);

		// Y-Axis which is green
		const yAxisMaterial = new THREE.LineBasicMaterial({color: 0x00FF00});
		const yPoints = [];
		yPoints.push( new THREE.Vector3(0, 0, 0));
		yPoints.push( new THREE.Vector3(0, range, 0));
		const yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
		const yAxisLine = new THREE.Line(yAxisGeometry, yAxisMaterial);

		// Z-Axis which is blue
		const zAxisMaterial = new THREE.LineBasicMaterial({color: 0x0000FF});
		const zPoints = [];
		zPoints.push( new THREE.Vector3(0, 0, 0));
		zPoints.push( new THREE.Vector3(0, 0, range));
		const zAxisGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
		const zAxisLine = new THREE.Line(zAxisGeometry, zAxisMaterial);

		scene.add(xAxisLine);
		scene.add(yAxisLine);
		scene.add(zAxisLine);

		 */
	}

	function renderTextures()
	{
		scene.remove(mesh);

		const boxGeometry = new THREE.BoxBufferGeometry(2, 2, 2);
		const loader = new THREE.TextureLoader();
		const material = new THREE.MeshBasicMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')});

		const materials = [
			new THREE.MeshBasicMaterial({map: loader.load('https://res-3.cloudinary.com/crunchbase-production/image/upload/c_lpad,f_auto,q_auto:eco/taqpepcwzincpeytldot')}), //front right
			new THREE.MeshBasicMaterial({map: loader.load('https://static.wikia.nocookie.net/haikyuu/images/a/a1/Haikyuu_Poster.png/revision/latest/top-crop/width/220/height/220?cb=20140326213635')}), // back left
			new THREE.MeshBasicMaterial({map: loader.load('https://static.wikia.nocookie.net/leagueoflegends/images/8/8e/Kayn_Render.png/revision/latest/top-crop/width/360/height/360?cb=20181117175535')}), // top
			new THREE.MeshBasicMaterial({map: loader.load('https://cdn.vox-cdn.com/thumbor/wQooBXM6ZRWVCkdI6W_KgDR1sjc=/0x0:1920x1200/1400x1400/filters:focal(1313x531:1619x837):format(jpeg)/cdn.vox-cdn.com/uploads/chorus_image/image/53947575/reinhammer.0.jpg')}), // bottom
			new THREE.MeshBasicMaterial({map: loader.load('https://i1.sndcdn.com/artworks-000118414405-0c9zmf-t500x500.jpg')}),// front left
			new THREE.MeshBasicMaterial({map: loader.load('https://cdn1.i-scmp.com/sites/default/files/styles/768x768/public/images/methode/2018/12/28/f137ab00-0996-11e9-8e9f-24e0f03e43a7_image_hires_175807.jpg?itok=4dAlR0QI&v=1545991093')}), // back right
		];

		// If we want to apply a single texture change the second parameter to the material variable
		// Otherwise use materials variable
		mesh = new THREE.Mesh(boxGeometry, materials);

		scene.add(mesh);
	}

	// Handle resizing of the browser window.
	function handleResize()
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function loadCubeJustVertices()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);
		scene.remove(bunnyMesh);

		// Adding a material to make the vertices visible
		// Points material only shows the points which in our case are 8 vertices
		const material = new THREE.PointsMaterial({color: 0x00ff00, size: 0.1});
		mesh = new THREE.Points(geometry, material);

		const bunnyMaterial = new THREE.PointsMaterial({color: 0x00ff00, size: 0.01});
		bunnyMesh = new THREE.Points(bunnyObject.children[0].geometry, bunnyMaterial);
		// Adjust scale
		bunnyMesh.scale.set(0.3, 0.3, 0.3);

		// Add the mesh back in the scene
		scene.add(mesh);
		scene.add(bunnyMesh);
	}

	function loadCubeJustEdges()
	{
		// Remove the current mesh as we need to render a new mesh
		scene.remove(mesh);
		scene.remove(bunnyMesh);

		// Adding a material to make the edges/wireframe visible
		// The material is told only to show the wireframe of the geometry
		const material = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true});
		mesh = new THREE.Mesh(geometry, material);

		// Apply material to object
		bunnyMesh = new THREE.Mesh(bunnyObject.children[0].geometry, material);
		// Adjust scale
		bunnyMesh.scale.set(0.3, 0.3, 0.3);

		// Add the mesh back in the scene
		scene.add(mesh);
		scene.add(bunnyMesh);
	}

	function loadCube()
	{
		scene.remove(mesh);
		// Faces naturally render when you add the material
		const material = new THREE.MeshBasicMaterial({color: 0x0120FF});
		mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
	}

	function loadObject()
	{
		const loader = new THREE.OBJLoader();
		// load a resource
		loader.load(
				// resource URL
				'http://localhost:8000/bunny-5000.obj',
				// called when resource is loaded
				function ( object ) {
					object.scale.set(0.3, 0.3, 0.3);

					bunnyObject = object;

				},
				// called when loading is in progresses
				function ( xhr ) {

					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

				},
				// called when loading has errors
				function ( error ) {

					console.log( 'An error happened' );

				}
		);
	}

	// Animation loop function. This function is called whenever an update is required.
	function animate()
	{
		requestAnimationFrame(animate);

		// TO DO: This is a good place for code that rotates your cube (requirement 3).
		//mesh.rotation.x += 0.005;
		//mesh.rotation.y += 0.01;
		//mesh.rotation.z += 0.2;

		// Render the current scene to the screen.
		renderer.render(scene, camera);
	}

	// Handle keyboard presses.
	function handleKeyDown(event)
	{
		switch (event.keyCode)
		{
				// Render modes.
			case 70: // f = face
				loadCube();
				//for(mesh.)
				break;

			case 69: // e = edge
				loadCubeJustEdges();
				break;

			case 86: // v = vertex
				loadCubeJustVertices();
				break;

				// TO DO: add code for starting/stopping rotations (requirement 3).
			case 88: // x = trigger rotating cube about x axis
				mesh.rotation.x += 0.01;
				if(bunnyObject != null)
				{
					bunnyObject.rotation.x += 0.01;
				}

				break;

			case 89: // y = trigger rotating cube about y axis
				mesh.rotation.y += 0.01;
				if(bunnyObject != null) {
					bunnyObject.rotation.y += 0.01;
				}
				break;
			case 90: // z = trigger rotating cube about z axis
				mesh.rotation.z += 0.01;
				if(bunnyObject != null) {
					bunnyObject.rotation.z += 0.01;
				}
				break;

			case 82: // r = reset rotation
				mesh.rotation.x = 0;
				mesh.rotation.y = 0;
				mesh.rotation.z = 0;
				if(bunnyObject != null) {
					bunnyObject.rotation.x = 0;
					bunnyObject.rotation.y = 0;
					bunnyObject.rotation.z = 0;
				}
				break;

			case 38: // arrow up
				camera.translateY(0.05);
				break;

			case 40: // arrow down
				camera.translateY(-0.05);
				break;

			case 37: // arrow left
				camera.translateX(-0.05);
				break;

			case 39: // arrow right
				camera.translateX(0.05);
				break;

			case 87: // w = camera forward
				camera.translateZ(-0.05);
				break;

			case 83: // s = camera backwards
				camera.translateZ(0.05);
				break;

			case 84: // t = render textures

				renderTextures();
		}
	}
</script>
</body>
</html>